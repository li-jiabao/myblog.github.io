```
title: 算法学习的基础知识
author: lijiabao
date: 2021-03-18 14:30
categories: Alogrithm
tags: Alogrithm
```

这篇文章主要是介绍一下学习算法之前的一些必要的基础知识,如算法复杂度和算法的一些特性

## 算法


算法就是基于特定的计算模型，旨在解决某一信息处理问题二设计的指令序列

### 算法的几大特性

- 输入输出：算法问题总是有输入的问题和输出的结果
- 确定性和可行性：算法应该可以描述为若干个语义明确的基本操作组成的指令，并且每一个操作都是可以完成实现的
- 有穷性和正确性：算法都应在有限次的基本操作之后结束输出（有穷性），而且算法的输出结果能够符合由问题本身设计的条件（正确性）
- 单调性和不变性：用来证明有穷性和正确性的重要技巧，就是找出算法具有的不变性和单调性。单调性是指随着算法的不断推进问题的有效规模会不断递减。不变性不仅应该在算法初始状态满足而且应该与算法最终的正确性向呼应。
- 退化和鲁棒性：退化是指各种极端情况。算法的鲁棒性是指算法在碰见退化情况也能够保证算法的正确性而不出现异常。
- 重用性：算法可以推广适用于不同的类型问题

### 算法效率

- 可计算性：算法首先需要保证代码的合法性，同时还能满足正常执行不报错
- 难解性：算法在满足了正确性和有穷性的基础上，我们还关心执行的效率和所花的时间。尽管如此还是有许多的问题已超出目前系统提供的计算能力，这类问题称为难解性问题
- 计算效率：对于一般性问题，应该更加关注如何高效的解决问题，算法效率通过时间和空间复杂度来评判
- 数据结构：算法的输入输出都是数据的形式表达，因此对于数据的存储、组织、转移和变换的操作效率也会直接影响算法的整体效率。因此，想要建立高效的算法，要做到根据实际自如的设计、实现和下选用合适的数据结构、需要对算法设计的技巧和数据结构的特性有很深入的了解。

### 算法复杂度

#### 时间复杂度

时间复杂度的分析评判通过问题的实际规模来评判，问题规模越接近，计算成本越接近，随着问题规模上升，计算成本增加。

#### 渐进复杂度

小规模问题的处理时间本来就相对较少，差异不明显，对于大规模问题的处理差异更显著，这种着眼长远、关注事件复杂度的总体变化趋势和增长速度的方法称为渐进分析

#### 空间复杂度

除了时间的长度，算法所需的存储空间也是衡量性能的一个重要方面

#### 输入规模

对算法复杂度的界定，都是相对于问题的输入规模而言的。由于不同人不同场合对于规模的界定不一样，可能导致算法都咋读有差异。

严格说：待计算问题的输入规模。应严格定义为“用于描述输入所需的空间规模”

关于`countOnes()`计算数值二进制位数为1的数量的算法复杂度为O(logn)的结论，是相对于输入整数本身的数值n而言；而若以n二进制展开的宽度作为输入规模，则应为线性复杂度O(r)。`power2BF_I()`算法的复杂度为O(2^r^)的结论，是相对于输入指数n的二进制数位r而言；而若以n本身的数值作为输入规模，却应为线性复杂度O(n)。因此就上述两个例子而言，将输入参数n二进制展开的宽度r作为输入规模更为合理。也就是说，将这两个算法的复杂度界定为O(r)和O(2^r^)更妥。对应地，以输入参数n本身的数值作为基准而得出的O(logn)和O(n)复杂度，则应分别称作伪对数的（pseudo-logarithmic）和伪线性的（pseudo-linear）复杂度。

#### 复杂度计算方法

#####  **大O记号**

同样地出于保守的估计，我们首先关注T(n)的渐进上界。为此可引入所谓大O记号。具体地，若存在正的常数c和函数f(n)，使得对任何n >> 2都有 $T(n) <=c∙f(n)$则可认为在n足够大之后，f(n)给出了T(n)增长速度的一个渐进上界。此时，记之为：$T(n)  =  O(f(n))$

由这一定义，可导出大O记号的以下性质：

1. 对于任一常数c > 0，有 $O(f(n))  =  O(c∙f(n))$
2. 对于任意常数a > b > 0，有 $O(n^a + n^b)  =  O(n^a)$

可以看出，大O记号的这些性质的确体现了对函数总体渐进增长趋势的关注和刻画

##### **大$\Theta$记号**

是对算法的准确估计，如果存在正的常数c~1~ < c~2~和函数h(n)，使得对于任何n >> 2都有:

$c1∙h(n) <= T(n) <= c2∙h(n)$

就可以认为在n足够大之后，h(n)给出了T(n)的一个确界。此时，我们记之为：$T(n) = \Theta(h(n))$

##### **大$\Omega$记号**

为了对算法的复杂度最好情况做出估计，需要借助另一个记号。如果存在正的常数c和函数g(n)，使得对于任何n >> 2都有:

$T(n) >= c∙g(n):$

就可以认为，在n足够大之后，g(n)给出了T(n)的一个渐进下界。此时，我们记之为：$T(n) = \Omega(g(n))$是

对算法执行效率的乐观估计。对于规模为n的任意输入，算法的运行时间都不低于$\Omega(g(n))$

#### 常见复杂度类型

##### 常数型$O(1)$

常数时间复杂度算法：仅含一次或者常数次基本操作的算法，此类算法通常不包含循环、分支、子程序调用等该类算法仅需要常数规模的辅助空间，此类只需要$O(1)$辅助空间的算法，称为就地算法

##### 对数型$O(logn)$

对数多项式时间复杂度的算法：凡是运行时间可以表示为$T(n) = O(log^cn)$这类形式的算法（比如每一步操作之后n都减半的操作）都统称为对数多项式复杂度算法，此类算法虽不如常数型理想，但也是一种极为高效的算法。

##### 线性$O(n)$

线性时间复杂度算法：时间度量可以表示为$T(n)=O(n)$形式的算法，均称为线性时间复杂度算法，类似的有数组的遍历，循环之类的。此类算法的效率亦足以满意

##### 多项式$O(polynomial(n))$

多项式时间复杂度算法：若是运行时间度量为$T(n)=O(f(n))$这类算法，比如冒泡排序算法的复杂度就属于此类算法O(n^2^)。其中的f(n)属于多项式，线性时间复杂度属于多项式的一个特例。若是某个问题属于这类算法，则称该算法问题为可有效求解或

##### 指数型$O(2^n)$

指数时间复杂度算法：时间度量为$T(n)=O(a^n)$的这类算法(a > 1)，比如幂函数运算的蛮力迭代。

从常数、对数、线性、平方到多项式时间复杂度还在可接受的范围，然而多项式和指数式复杂度之间，有一道鸿沟，当问题的规模较大后，指数复杂度算法的实际效率急剧下降，计算时间之长达到令人难以忍受，通常认为，指数时间复杂度的算法难以应用到实际问题，不属于有效算法。不存在多项式复杂度算法的问题，也成为**难解问题**

实际上很遗憾，绝大多数计算问题并不存在多项式时间的算法，试图解决这类算法，至少都需要指数数量级的运算时间。

![典型算法复杂度层次](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/%E5%85%B8%E5%9E%8B%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B1%82%E6%AC%A1.png)

需要注意的是，上图中的左侧在问题规模较小时，指数复杂度显得比某些多项式更低，这只是规模较小时的情况，一旦问题规模上来了，算法复杂度爆炸式增长。



### 递归

> 递归是一种解决问题的有效方法，递归就是在运行过程中调用自己，也就是允许函数和过程进行自我调用。
>
> 函数和过程及其之间的相互调用，是实现分支转向的重要机制，而分支转向是算法的灵魂。
>
> 递归调用可以是直接的自我调用，也能以间接的方式出现，如：先调用某个方法，再辗转通过其他方法又调用自身

#### 线性递归

典型的线性递归可以用数组求和来作为示例展示：

```Java
public class ArraySum{
    public static void main(String[] args){
        int[] a = new int[10];
        for (int i=0;i < 10;i++) a[i] = i;
        int sum = new ArraySum().sumArray(a, 10);
    }
    public int sumArray(int[] array, int n){
        if (n < 1) return 0; // 平凡情况，递归基
        else return sumArray(array, n-1) + array[n-1]; // 一般情况
    }// 递归深度*O(1)= (n+1)*O(1)=O(n)
}
```

线性递归的模式，往往对应着减而治之的算法策略：递归每深入一层，待求解问题规模都会缩减一个常数，直到最后蜕化成平凡的小问题

#### 递归分析

递归的算法时间和空间复杂度和常规算法不一样,有其自身的规律和特定的技巧,以下介绍递归跟踪和地推方程这两种主要的方法.

##### 递归跟踪

作为一种只管且可视的方法,递归跟踪(recursion trace)分析递归算法的总体运行时间和空间,按照以下的原则将递归算法的执行过程整理为图的形式:

1. 算法的每一递归实例都表示为一个方框,其中注明了该实例调用的参数
2. 若是实例M调用N,则在M和N对应的方框之间添加一条有向连线

![递归跟踪分析](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/%E9%80%92%E5%BD%92%E8%B7%9F%E8%B8%AA%E5%88%86%E6%9E%90.png)



##### 递推方程

与递归追踪不同,不需要将具体的调用过程画出,而是通过对递归模式的数学归纳,导出复杂度定界函数的递推方程及其边界条件,从而将复杂度的分析转化为递推方程(组)的求解

总体思路上,这个方法和微分方程相似:很多复杂函数的显式通常不容易直接获得,但是却有某些相对简洁的规律可以遵循,通过求解描述这些规律的一些方程组,可求解出最终函数的解.通常需要一定的边界条件才可以获得相对唯一的解.对于边界条件,递归中往往使用递归基作为边界条件



#### 递归模式

##### 多递归基

为了保证有穷性,递归算法需要设置递归基确保可以执行到并结束递归.针对每一类可能出现的平凡情况,都需设置对用的递归基,因此同类算法的递归基可能不止一个

##### 实现递归

设计递归算法时,往往需要多个角度反复尝试,方能确定问题的输入及其规模的最佳划分方式.有时候还需从不同角度定义和描述原问题,使得经原问题分解的所有子问题和原问题有一样的语义

##### 多向递归

递归方法中,可能不止递归基有多个,递归的调用也有多种可供选择的分支

#### 递归消除

- 空间成本: 递归算法消耗的空间主要取决于递归深度,相比迭代版,消耗的空间更多,并可能影响实际运行速度.此外,对于操作系统来说,实现递归需要花费大量额外的时间创建维护和销毁递归实例,也会加大计算机负荷,有些时候,对于运行速度和存储空间要求较高的场合,会考虑将递归改写为非递归版本
- ~~尾递归及其消除:~~在线性递归算法中,若是递归调用在递归实例中恰好以最后一部操作的形式出现,则称为尾递归.尾递归的消除均可以比较简洁的转换为等效的迭代版本

#### 二分递归

对于规模庞大的应用问题,往往可以采用分而治之的策略来将规模庞大的问题切分成若干个规模较小的子问题与减而治之策略一样，这里也要求对原问题重新表述，以保证子问题与原问题在接口形式上的一致。每一递归实例都可能做多次递归，故称作“多路递归”（multi-way recursion）。通常都是将原问题一分为二，故称作“二分递归”（binary recursion）。需强调的是，无论是分解为两个还是更大常数个子问题，对算法总体的渐进复杂度并无实质影响。

下面是数组求和的二分递归实现方法:

```java
public class ArraySum{
    public static void main(String[] args){
        int[] a = new int[10];
        for (int i=0;i < 10;i++) a[i] = i;
        int sum = new ArraySum().sumArray(a, 1, 10);
    }
    public int sumArray(int[] array, int lo, int hi){
        if (hi - lo == 1) return array[lo]; // 平凡情况，递归基(区间长度已经降低为1)
        else {
            int min = (lo + hi) / 2;// 以中间点为界,一分为二
            // 对一分为二的两个子数组求和并汇总
            return sumArray(array, lo, min) + sumArray(array, min, hi);
        }
    }// O(hi-lo+1),线性正比于区间长度
}
```

![二分递归的递归跟踪分析](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/%E4%BA%8C%E5%88%86%E9%80%92%E5%BD%92%E7%9A%84%E9%80%92%E5%BD%92%E8%B7%9F%E8%B8%AA%E5%88%86%E6%9E%90.png)

**效率**
当然，并非所有问题都适宜于采用分治策略。实际上除了递归，此类算法的计算消耗主要来自两个方面。首先是子问题划分，即把原问题分解为形式相同、规模更小的多个子问题，比如代码1.11中sum()算法将待求和数组分为前、后两段。其次是子解答合并，即由递归所得子问题的解，得到原问题的整体解，比如由子数组之和累加得到整个数组之和。为使分治策略真正有效，不仅必须保证以上两方面的计算都能高效地实现，还必须保证子问题之间相互独立各子问题可独立求解，而无需借助其它子问题的原始数据或中间结果。否则，或者子问题之间必须传递数据，或者子问题之间需要相互调用，无论如何都会导致时间和空间复杂度的无谓增加。以下就以Fibonacci数列的计算为例说明这一点.因此盲目的二分递归是不可取的,应该考虑实际的情况选择方法计算.

相比之下,使用了迭代方法计算Fibonacci数列的时间和空间复杂度都比二分递归更优秀.

### 抽象数据类型

各种数据结构都可看作是由若干数据项组成的集合，同时对数据项定义一组标准的操作。现代数据结构普遍遵从“信息隐藏”的理念，通过统一接口和内部封装，分层次从整体上加以设计、实现与使用。
所谓封装，就是将数据项与相关的操作结合为一个整体，并将其从外部的可见性划分为若干级别，从而将数据结构的外部特性与其内部实现相分离，提供一致且标准的对外接口，隐藏内部的实现细节。于是，数据集合及其对应的操作可超脱于具体的程序设计语言、具体的实现方式，即构成所谓的抽象数据类型（abstract data type, ADT）。抽象数据类型的理论催生了现代面向对象的程序设计语言，而支持封装也是此类语言的基本特征。