---
title: 算法分析的数学模型
author: lijiabao
date: 2021-03-22 22:30
categories: ["DataStruture and Alogrithm"]
tags: ["DataStruture and Alogrithm"]
---

这里主要介绍了算法的数学模型分析，并列举了集中常见的增长数量级。然后对于性能优化和一些算法注意事项做了简要描述。最后介绍了Java中内存的占用消耗情况

## 数学模型

尽管许多复杂的因素影响着我们对程序的运行时间，但是原则上我们仍然可能构造出一个数学模型来描述程序的运行时间，程序运行的时间主要和两个部分有关：

- 程序执行每条语句所用时间：这取决于计算机、编译器和操作系统
- 程序执行每条语句的频率：这取决于程序本身和输入

有些语句分析比较简单，但是有些语句需要更加深入的分析才能知道语句执行频率。

#### 数学表达式简化

频率分析有时候会出现很复杂的数学表达式，因此有时候对于这种复杂的表达式，为了更方便的理解计算，需要进行一定的简化，比如消除某些小项只保留大项，这样会大大简化计算。

#### 运行时间近似

需要研究Java编译器来找出每条指定对应的及其指令数，并根据计算机的指令龟蛋得到每条机器指令的运行时间，然后才能得到总运行时间。往往大多数时候，程序的运行时间只取决于其中一小部分的指令。

#### 算法的分析

有时候算法的优劣往往对于运行时间影响很大，如果碰到运行时间长的情况，可以看看是否可以改进算法来提升运行速度。不同算法数量级增长可能会有很大的差距。

#### 成本模型

我们使用成本模型来评估算法性质，这个模型定义了我们研究的算法中的基本操作，类似三元组求和为零的算法的成本模型：在研究解决该问题的算法时，记录的时数组的访问次数（无论读写）

> 命题B：三元组的求和为零的暴力算法使用了~N3、2次数组访问来计算N个整数中和为零的整数三元组的数量
>
> 证明：该算法访问了N3/6个整数三元组中的所有三个整数

使用命题来报销某个成本模型下算法的数学性质，希望可以通过成本模型使得给定实现所需的运行时间的增长数量级和他背后的算法的成本的增长数量级相同

#### 总结

对于大多数城西，得到其运行时间的数学模型所需步骤如下：

- 确定输入模型以及定义问题的规模
- 识别内循环
- 根据内循环中的操作成本模型
- 对于给定输入，判断这些操作的执行频率，可能需要数学分析

举个二分查找算法的例子：

- 输入模型时大小为N的数组
- 内循环时while循环中的所有语句
- 内循环的操作成本模型是：比较操作（比较两个数组元素的值）

## 增长数量级的分类

- 常数级别：c
- 对数级别：logN
- 线性级别：N
- 线性对数级别：NlogN
- 平方级别：N2
- 立方级别：N3
- 多项式级别
- 指数级别：2n



## 注意事项

对程序性能进行仔细分析时，得到的不一致的结果可能是由于假设并不完全正确导致的

#### 大常数

我们在忽略低级项中的常数系数，这可能是不正确的，当常数项比较大的时候，近似忽略就是不正确的了

#### 非决定性的内循环

内循环是决定性因素的假设并不总是正确，错误的成本模型可能无法得到真正的内循环，问题的规模N也许没有大到对指令的执行频率的数学描述中的首项大大超过其他低级项并可以忽略他们的成都。有些程序在内循环之外也有大量指令需要考虑。成本模型可能还需要改进

#### 指令时间

每条指令的所需时间总是相同的假设并不总是正确。比如现在的计算机系统都会使用缓存技术组织内存

#### 系统因素

计算机中运行着许多的程序，本身系统资源的占用情况就不一定一样，所以，不同系统类型和状态都会影响程序的性能。

#### 不同场景的差异

比较两个执行相同任务的程序，在不同的场景运行速度有差异，这往往是之前提到的一些因素造成的，像这种优化一般留给专家解决就好了

#### 输入的强烈依赖

不同的数据输入也会造成程序的性能不一致的问题，有些输入很快得出结果，有些输入需要花很长时间完成，这和输入有很大的关系



## 对输入依赖的处理（改善性能）

为了更好的预测算法的性能，就需要细致的处理输入，让其更符合实际，让预测结果更有代表性

#### 输入模型

一种方法是更小心的对需要解决的问题输入进行处理建模。比如假设所有的输入均为随机数，但是这种方法有困难：

- 输入模型可能不切实际（这个更重要，因为计算目的就是为了发现输入的性质）
- 输入的分析可能极端困难，所需的技巧性过高

#### 对最坏情况的性能保证

也就是程序运行时间上限：从悲观的角度来估算算法性能，最坏情况运行时间是多少

#### 随机化算法

为性能提供保证的一种重要方法是引入随机性。比如快速排序算法，在最坏情况下是平方级别，但是随机打乱输入，根据概率可以保证是线性对数的，每次运行该算法，所需时间均不相同，但是运行时间超过线性对数的可能性小到可以忽略

#### 操作序列

对于不同的操作顺序，可能得到的程序性能也不一样。如下压栈：先压入N个值在全部弹出的性能和N次压入弹出操作得到的性能可能不相同

#### 均摊分析

提供性能保证的另一种方法是通过记录所有操作的总成本并除以操作总数来将成本均摊。可以允许执行一些昂贵的操作，但保持所有操作的平均成本较低

算法分析者和程序员的任务不一样：

- 分析者任务就是尽可能解释关于某个算法的更多信息
- 程序员的任务就是利用这些信息开发有效解决问题的程序，也就是找到算法合适的应用场景并很好嵌入

## 内存

程序对于内存的使用也和物理世界直接相关：计算机中的电路很大一部分就是帮助程序保存一些值并在稍后取出他们，需要存储的值越多需要的电路就越多。

Java中最重要的特性之一就是他的内存分配系统，目的就是为了从内存的操作中解脱出来。

分析内存的使用比分析程序所需的运行时间简单，因为设计的程序语句少，且可以将复杂的对象简化为原始数据类型，而原始数据类型的内存使用是预先定义好的：只需要将变量的数量和他们的类型所对应字节数项乘汇总就可。

计算机的内存单位：

- 位：最小的单位
- 字节：一字节8位
- 字：通常由16位、32位或者64位组成

基本数据类型的内存占用：

- byte：1字节
- char：2字节
- short：2字节
- int：4字节
- long：8字节
- float：4字节
- double：8字节
- boolean：1（数组类型变量）字节或者4（基本类型变量）字节

#### 对象

要知道一个对象使用的内存量，需要将所有实例变量使用的内存和对象本身的开销（一般是16字节）相加

- 对象开销：16字节
- 填充字节：4字节
- 内部类额外开销：8字节
- 引用金额String引用字节：8字节并不包含引用对象所占的字节数

![典型对象的内存使用](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/%E5%85%B8%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5.png)

#### 链表

嵌套的非静态（内部）类需要额外的8字节（指向外部类的引用）

因此Node对象需要使用（16字节对象开销，Item和Node对象引用各8字节再加上外部类引用的额外8字节，总共40字节）

因为Integer对象需要使用24字节，因此一个含有N个整数的基于链表的栈需要使用（32+64N）字节，包含stack对象的16字节的开销，引用实例变量的8字节，int实例变量4字节，4个填充字节，然后每个元素使用64字节（Node对象40字节和Integer对象的24字节）

#### 数组

Java中数组被实现为对象，他们一般都会因为记录长度而需要额外的内存。一个原始数据类型的数组一般需要24字节的头信息（16字节的对象开销，4字节用于保存长度以及4填充字节）再加上保存值所需的内存：

- 一个含有N个int值的数组需要（24+4N）字节
- 一个含有N个double值的数组需要使用（24+8N）字节
- 对象的数组就是对象所需内存加上引用所需的额外内存，如date类对象，就是（24+32N+8N）

#### 字符串对象

String的标准实现含有4个实例变量：一个指向字符数组的引用（8字节）和三个int值（各4字节）。第一个int值描述的是字符数组的偏移量，第二个int值是一个计数器（字符串的长度）第三个int值是一个散列值。

因此每个字符串对象总共会使用40个字节（16字节表示对象的，12个字节是三个int值的，再加上数组的引用8字节和4个填充字节）这40字节是除了字符数组之外字符串所需的内存空间，所有字符所需的内存需要另计，String的char数组常常实在多个字符串之间共享的，因为String对象不可变的，这中设计让String能够在多个对象都含有相同的values数组时节省内存。

#### 字符串的值和子字符串

长度为N的String对象一般需要使用40字节（String对象本身）加上字符数组（24+2N）

但是字符处理经常和子字符串打交道，所以Java对字符串的表示希望能够避免复制字符串中的字符。调用subString()方法时，创建了一个新的字符串对象，但是重用了相同的values数组，因此子字符串指挥使用40字节内存

含有原始字符串的字符数组的别名存在于子字符串，子字符串对象的偏移量和长度域标记了子字符串的位置<font color="red">一个子字符串所需的额外内存是一个常数，构造一个子字符串的时间也是常数</font>

确保子字符串创建所需的空间（时间）和字符串长度无关时许多基础字符串处理算法效率的关键所在

![字符串和子字符串内存消耗](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97.png)

Java的内存区：

- 堆区：存放的是new创建对象是，从堆内存的另一块特定区域为该对象分配需要的内存，所有对象会一直存在，知道对他的引用消失，此时系统的垃圾回收会将它所占用的内存回收到堆中（这个动态过程很难准确估计程序的内存使用）
- 栈区（Java系统的下压栈）：系统会从内存中的特定区域（栈）为方法分配内存（用于保存局部变量），方法返回时，所占用的内存被返回给了系统栈

#### 展望

良好的性能非常重要，速度极慢的程序和不正确的程序一样无用，因此有必要在一开始就关注程序的运行成本，这可以大致估计出所要解决问题的规模，**更聪明的做法是时刻关注程序中的内循环代码组成**

但是**过于关注程序的性能是最常见的错误**。程序员最重要的任务是写出清晰正确的代码，提升性能的事最好交给专家来做。

> 不成熟的优化是所有罪恶之源   ——Hoare（快排发明人）

**第二常见的错误是完全忽略了程序的性能**