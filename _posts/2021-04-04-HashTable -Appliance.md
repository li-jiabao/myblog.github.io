---
title: 符号表应用
author: lijiabao
date: 2021-04-04 23:30
categories: ["查找", "DataStruture and Alogrithm"]
tags: ["查找", "DataStruture and Alogrithm"]
---

介绍散列表在计算机领域的应用

## 符号表应用

符号表比较有代表性的应用：

- 快速从文件中提取由逗号分隔的信息的字典程序和索引程序。逗号分隔常用于存储网络信息
- 为文件构建索引的程序
- 表示习稀疏矩阵的数据类型

同时很多相关的算法也会使用符号表来实现或者优化：

- 图算法利用符号表来实现
- 字符串处理也会使用符号表
- 对于动态规划的重叠子问题可以使用符号表实现

### 符号表的选择问题

各种符号实现的优缺点：

| 符号表实现     | 优点                                                         | 缺点                                                         |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 二叉树         | 实现比较简单，代码量少，有较为不错的 效率                    | 性能是几种实现中最低的                                       |
| 红黑树         | 能保证最坏情况下的性能，支持的操作多，支持有序性操作         | 实现比较麻烦，代码量不少，删除麻烦                           |
| 拉链法散列表   | 如果可以准确预测数组大小，可以不用动态调整，查找效率值很高，代码更加简单 | 内存消耗比较高，需要均匀独立的散列函数，实现有序性操作效率不高 |
| 线性探测散列表 | 代码简单，查找时间最优                                       | 需要动态调整数组大小，删除耗时比较高，散列函数设计麻烦       |

总的来说：散列表的优点在于代码简单，查找时间最优（常数级别），二叉查找树抽象结构简单，不需要设计散列函数，而红黑树可以保证最坏情况的性能且支持操作多（有序性操作）

大多数程序员第一选择都是散列表，其他因素更重要才选择红黑树。

字符串中有一个应用：键都是长字符串时，可以构造出一个比红黑树更灵活比散列表更高效的数据结构。

![image-20210404170904349](C:%5CUsers%5Cjiabao%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210404170904349.png)

实际上，不管使用哪种数据结构，只要在使用的时候测试一下你选择的数据结构是否满足你需要的性能条件就好。有时候可能根据实际需要，还需要对数据结构进行改善修改。

#### 符号表的一些改进修改

之前介绍的标准符号表实现尽管已经适用于很多的场景，但是在有些场景可能需要改善代码结构使得可以满足新的场景

##### 原始数据类型

如果符号表存储的时整形的键对应浮点型的值，这个时候如果使用标准实现，需要使用这两种类型的包装类，因此就需要两个额外的引用来访问键值对，当键值对较多的时候，内存开销就会有点多。这个时候如果符号表的实现可以使用原始数据类型来代替就可以减少不少的开销。因此当你需要性能并且有内存要求的时候，可以进行改进（并不困难）

##### 重复键

符号表的实现并不支持重复键，但实际上应用中可能需要考虑重复键。例如之前交易数据类型，可能多笔交易中的客户都是同一个。

对于这类情况的实现，可以考虑是实现的时候允许数据结构保存重复的键，然后在查找的时候随机返回对应的多个值中的一个，也可以定义方法返回所有对应的值。对于二叉树和散列表的修改并不难，但是红黑树的实现就略微有点困难

### 集合API

有些时候，并不需要处理值，只需要能够将键插入表中并检测一个键在表中是否存在，不允许存在重复的键。

下面时集合对应的API，只处理键，并不需要对值进行处理：

| API                        | 解释                                       |
| -------------------------- | ------------------------------------------ |
| public class SET<Key>      | 定义一个集合类，只处理键，不允许出现重复值 |
| SET()                      | 构造函数，创建一个集合                     |
| void add(Key key)          | 添加集合键                                 |
| void delete(Key key)       | 删除键                                     |
| boolean contains(Key key ) | 判断键在集合中是否存在                     |
| boolean isEmpty()          | 判断集合是否为空                           |
| int size()                 | 获取集合的大小                             |
| String toString()          | 返回集合的字符串表示                       |

只要忽略键对应的值，或者使用一个简单的类进行封装就可以将符号表实现为SET

对于集合的并、交、补等操作的算法实现稍微有些复杂。

对于符号表实现的SET分为有序和无序。对于有序的集合可以实现有序性操作的API。

#### 过滤器

对于简单过滤器的实现代码：

```java
public class SimpleFilter
{
    public static void main(String[] args)
    {
        SET<String> set = new SET<String>(); // 创建一个集合对象来实现过滤器功能
        while (!StdIn.isEmpty())
        {
            String key = StdIn.readString();
            if (!set.contains(key))
            {
                set.add(key);
                System.out.println(key);
            }
        }
    }
}
```

#### 白名单和黑名单

过滤器的另外一个经典应用是使用一个文件中保存的键来判断输入流中的哪些键可以传入，这种被称为白名单，对于在文件中的键判断是否存在，存在则不能传入的实现称为黑名单：

```java
public class WhiteList
{
    public static void main(String[] args)
    {
        FileInputStream in = new FileInputStream("filename");
        DataInputStream data = new DataInputStream(in);
        SET<String> set = new SET<String>();
        while (!data.isEmpty())
        {
            set.add(data.readString());  // 从文件中读取字符串添加到集合中
        }
        // 在这里实现判断键是否在集合中操作，如果在，就可以让这个内容传入进行处理，不在就忽略
    }
}
```

### 字典类应用

符号表实际应用情况：

- 电话联系人列表：键是联系人姓名，值是联系人的电话
- 字典：键是单词，值是单词的解释
- 账户信息：股票名称是键，股票信息是值
- 实验数据组织：符号表实现的高级数据结构和算法是科学研究重要的内容
- 编译器：符号表的早期应用就是组织代码信息。最早的实现是通过符号为键，操作和内存地址是键对应的值，这样方便记忆和代码编写
- 文件系统：文件名是键，文件内容的地址是值，两者关联组成文件系统
- 互联网DNS：域名系统（DNS）是互联网信息组织基础，这个是通过将URL和计算机中的IP地址进行关联。这样就可以使用便于记忆的域名而不是使用IP来访问互联网

### 索引类应用

上述介绍的字典类主要特点是每个键都有一个与之关联的值，因此指定一个键对应一个值的符号表数据类型正好。但是实际一个给定的键可以有多个值，对于这种一个键和多个值相关联的符号表用索引来表示，索引的实际应用：

- 商业交易数据：使用客户的账号来跟踪一天所有的交易，对于这种数据，可以创建一个索引，键是客户账户，值是账号对应的所有交易信息
- 网络搜索：输入一个关键字，可以得到一系列和关键字相关的内容，这也是一个索引的实际应用
- 电影和演员：一部电影（键）对应多个演员（值）也属于索引

对于索引数据类型的创建比较简单：就是利用符号表来实现，只是将值的放入一个数据结构保存就可以，只要和键相关的值都放入该数据结构中，访问值的时候，就只需要访问该数据结构读取就好

还有一种特殊的索引：反向索引，使用值来查找键。

- 电影数据库：和前面正向索引不一样，这个反向索引是指查找演员出演过的电影信息。
- 文件搜索：操作系统中的关键字搜索文件的功能，关键字是键，出现关键字的所有文件是值
- 图书索引：书中的索引，可以让你查找一个术语和它在书中出现过的页码。还有一种对照索引：给出每个单词在书中出现的所有位置

### 稀疏向量

稀疏向量是符号表在科学和数学计算领域的应用

计算矩阵和向量的乘法：给定一个矩阵和一个向量并计算结果向量，其中第i项的值为矩阵的第i行和给定的向量的点乘。这个简单的代码实现比较简单，但是需要的时间和矩阵大小N×N有关，需要和N×N成正比的时间，空间也一样。

```java
double[][] a = new double[N][N];
double[] x = new double[N];
double[] b = new double[N];
for (int i = 0; i < N; i++)
{
    double sum = 0.0;
    for (int j = 0; j < N; j++)
        sum += a[i][j]*x[j];
    b[i] = sum;
}
```

这种实现内存和时间消耗量巨大。好在矩阵常常是稀疏的，其中大多数项都是0，因此可以将这个矩阵表示为由稀疏向量组成的一个数组：

```java
public class SparseVector
{
    private HashMap<Integer, Double> map;
    public SparseVector()
    {
        map = new HashST<>();
    }
    public int size()
    { return map.size()}
    public double get(int i)
    {
        if (!map.contains(i)) return 0.0;
        return map.get(i);
    }
    public void put(int i, double x)
    {
        map.put(i, x);
    }
    public double dot(double[] that)
    {
        double sum = 0.0;
        for (int i : map.keys())
            sum += that[i]*this.get(i);
        return sum;
    }
    // 算法高效的原因是其将为零的项目排除，所需的乘法操作数量等于稀疏向量的非零项数目
}
```

巨型稀疏矩阵使用这个算法带来的效率改善很大，但是对于不那么稀疏的矩阵使用这个方法的消耗将会是巨大的

### 总结

符号表在很多实际运用中都能够节省大量的运行成本，使得各个领域原本完全无法想象的问题的解决称为可能，因此符号表给计算机领域带来的贡献是巨大的。符号表在科学和工程中带来的效率提升也是巨大的。

正是全球各地学者不断探索发展，符号表在许多的领域都有应用，图就是基于符号表实现的一种数据结构，字符串中处理也有很多和符号表相关的应用。因此好好掌握符号表的使用，对计算机高效工作的原理理解会更简单明了。