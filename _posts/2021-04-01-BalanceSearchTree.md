---
title: 平衡查找树
author: lijiabao
date: 2021-04-01 22:30
categories: ["查找", "DataStruture and Alogrithm"]
tags: ["查找", "DataStruture and Alogrithm"]
---

介绍几种平衡二叉树的概念和特点，以及如何实现这些平衡二叉树，对几种平衡二叉树的效率进行分析并总结对比这几种平衡二叉树的优缺点以及时间空间复杂度。

## 平衡查找树

前面了解的几种比较简单的符号表的数据结构的实现，虽然情况较好的情况下，算法的效率还不错，但是在最坏情况下的性能还是比较差。下面将会针对这个问题，去了解一下怎么样去更好的解决这个问题，来保证不论如何构造二叉树。都能保证它的运行时间都是对数级别的。

对于树的构造，为了更好的保证树的高度最小，要能够保证树是平衡的。如果可以达到树的平衡构造，树高为lgN，这样，树的效率就最高。这是较为理想的情况，但是<font color='red'>在动态插入中保证树的完美平衡，代价太高。

下面介绍一下稍微放松了完美平衡而实现的几种平衡树，这些平衡树都可以保证所有符号表的操作（除了范围查找）都可以在对数时间完成

### 2-3查找树

**2-结点**：标准二叉树中的结点，含有一个键和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-树中的键都大于该节点

**3-结点**：它含有两个键和三条链接，左链接指向的2-3树中的键都小于该节点，中链接指向的2-3树中的键都位于该节点的两个键之间，右链接指向的2-3树中的键都大于该结点

2-3查找树可能是一棵空树或者由2-结点或3-结点。一棵完美平衡的2-3查找树中的所有空链接到根节点的距离应该都是相同的。

![2-3查找树示意图](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/2-3%E6%9F%A5%E6%89%BE%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

#### 查找

将二叉查找树的查找算法一般化我们就可以得出2-3树的查找算法。首先将键与根结点进行比较，命中就返回，未命中就切换到相应的子树区间再次进行判断，如果命中就返回，未命中就继续像上面操作一样进行递归操作。如果递归到树结点为空链接，查找未命中。只是2-3树中对于3-结点的查找需要变更一下，小于两个键中最小的就在左子树查找，大于最大的就在右子树查找，对于中间值就取中间的子树查找。

![2-3查找示意图](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/2-3%E6%A0%91%E6%9F%A5%E6%89%BE%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

#### 插入

插入子结点时分为两种情况：

- 当查找未命中结束于一个2-结点，就将这个结点更改为一个3-结点即可解决问题
- 当查找未命中落在了一个3-结点，比较麻烦。也有好几种情况：全部为3-结点的情况，父结点为2-结点的3-结点，父结点为3-结点的3-结点，插入结点到根节点路径上全是3-结点

##### 2-结点插入新键

如果碰见命中结点为2-结点的情况，比较好办，将2-结点转换为3-结点即可

![命中2-结点的插入示意图](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/2-3%E6%8F%92%E5%85%A5%E4%B9%8B%E5%91%BD%E4%B8%AD2-%E7%BB%93%E7%82%B9.png)

##### 一棵只含有一个3-结点的树

因为命中的结点是3-结点，树中已经有两个键了，没有可再插入键的空间。

为了完成二叉树的平衡，先将键临时存入该结点中，使之成为4-结点（含有3个键，4个链接）。4结点可以比较方便的将其改成三个2-结点组成的2-3树（三个键处于中间的成为该子树的根结点，最小的位于左子树，最大的位于右子树。这颗更新后的子树属于平衡的二叉树，也是平衡的2-3树。更新完之后树的高度增加1

![只含有3-结点2-3树插入](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/%E5%8F%AA%E5%90%AB%E6%9C%893-%E7%BB%93%E7%82%B9%E7%9A%842-3%E6%A0%91%E6%8F%92%E5%85%A5.png)

##### 父结点为2-结点的3-结点

当命中的结点是3-结点，同时其父结点是2-结点时，这是可以先将该键和3-结点混合组成4-结点，然后将该4-结点的中位键移动至父结点中，原来的4-结点变成两个2-结点分别位于父结点的中间子树和右子树。

如此插入操作之后，父结点成为3-结点，最终的2-3树还是平衡的，此时的树的高度并未改变。

![父结点为2-结点的2-3树的插入](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/%E7%88%B6%E7%BB%93%E7%82%B9%E4%B8%BA2-%E7%BB%93%E7%82%B9%E7%9A%842-3%E6%A0%91%E6%8F%92%E5%85%A5.png)

##### 父结点为3-结点

当命中结点为3-结点且父结点为3-结点时，首先将命中结点变为4-结点，然后再将中键给到父结点，父结点再组成一个4-结点，依次往上哪个，直至碰见2-结点完成插入或者到达一个为3-结点的根节点，对这个根结点进行分解，变成两个3个2-结点的2-3树

##### 分解根节点

对于命中的3-结点的父结点时2-3树的根结点，且这个根结点也是一个3-结点，对于这种情况，需要对根节点进行分解，分解：首先将命中结点更改为4-结点，然后将这个4-结点的中键给到根节点成为4-结点，然后再对这个4-结点进行分解，得到3个2-结点的2-3树，这个操作使得树的高度增加了一。

![分解根节点](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/%E5%88%86%E8%A7%A3%E6%A0%B9%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E5%92%8C3-%E7%88%B6%E7%BB%93%E7%82%B9%E7%9A%843-%E7%BB%93%E7%82%B9%E6%8F%92%E5%85%A5.png)

##### 局部变换

对于2-3树中的4-结点分解有6种情况：

- 4-结点是根结点时，直接对这个结点进行分解，成为3个2-结点，从而完成插入操作
- 2-结点的左子结点
- 2-结点的右子结点
- 3-结点的左子结点
- 3-结点的中子结点
- 3-结点的右子结点

![4-结点的几种分解情况](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/2-3%E6%A0%91%E7%9A%84%E5%AF%B9%E4%BA%8E4-%E7%BB%93%E7%82%B9%E5%88%86%E8%A7%A3%E6%83%85%E5%86%B5%E6%B1%87%E6%80%BB.png)

上面的这些操作的变换都是局部的：除了相关的结点和链接之外不必修改或者检查树的其他部分，每次变换中，变更的链接数量不会超过一个很小的常数。这些操作不光在数的底部，数种的任何地方只要符合相应的模式，变换都可以进行。每个变换都会将一个键送到它的父结点种，并对链接进行相应的重构而不会涉及树的其他部分。

##### 全局性质

局部变换并不会影响树的全局有序性和平衡性：任意空链接到根节点的路径长度都是相等的。除了4-结点最后回到了根节点，这个时候的树的高度才会增加1，而其他的变换都不会改变树的高度以及树的有序性和平衡性。

![4结点变换并不影响书的有序性和平衡性](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/4-%E7%BB%93%E7%82%B9%E5%88%86%E8%A7%A3.png)

<font color='red'>对于2-3树算法理解的关键在于要理解所有的局部变换都不会影响整个树的有序性和平衡性</font>

##### 二叉树和2-3树的生长方向

<font color='red'>标准二叉树的生长从上向下生长</font>：二叉树插入先找到应该所处的位置，然后从这个位置开始给元素腾位置，然后腾位置的元素往下再继续找自己的位置，依次直到插入完成，并且树为二叉树

<font color='red'>2-3树的生长是由下向上的</font>：2-3树插入首先找到自己的位置，然后在这里找是否已经是2-结点，不是说明没有位置，这时候就需要进入这个3-结点组合成4-结点，组合完毕后进行位置的重排，然后让重拍之后的中间元素往上找自己的位置，这时候如果商议结点是2-结点，插入进来即可完成，不是就需要继续组合成4-结点再进行重排并往上找自己位置，如果一直找到根节点，根节点如果是2-结点，就插入成为3-结点，如果是3-结点，就组合成4-结点，分解成为3个2-结点（这时候树的高度会增加1）

#### 查找和插入效率

![2-3树的构造路径](https://cdn.jsdelivr.net/gh/li-jiabao/NoteImg@main/img/2-3%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E8%B7%AF%E5%BE%84.png)

2-3树的分析和二叉查找树的分析不太相同：对于2-3树的分析，更感兴趣的是最坏情况下的性能，而非一般情况，符号表的实现种，无法控制用例按照什么顺序向表中插入键，因此对于最坏情况的分析是唯一能够提供性能保证的方法。

> 对于一棵大小为N的2-3树的查找和插入操作，<font color='red'>访问的结点数必然不会超过lgN个</font>

对于2-3树，其实在最坏情况仍然有着较好的性能，每个操作中处理每个结点的时间都不会超过一个很小的常数，两个操都只会访问一条路径上的点，<font color='red'>任何查找或者插入的成本肯定不会超过对数级别</font>。完美的2-3树要平展的多。<font color='red'>10亿个结点的一棵树高度仅在19-30之间</font>。最多只需要访问30个结点就能够在10亿个键中进行任意查找和插入操作

**<font color='red'>实现的难点：</font>**

- 尽管可以使用不同的数据类型来表示2-结点和3-结点，但是由于需要处理的情况实在太多，利用这些实现大多数操作并不方便
- 还需要对两种类型的结点进行维护：键之间的比较，链接和其他信息从一种结点复制到另外一种结点，将结点从一种数据类型转换为另外一种数据类型等。
- 实现上述内容需要的代码量比较大，且产生的额外开销可能会使得实现比标准的二叉查找树更慢

